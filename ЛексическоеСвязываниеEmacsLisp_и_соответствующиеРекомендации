Лексическое связывание Emacs Lisp и соответствующие рекомендации

Опубликовано 11 сентября 2013 годапо Jisang Yoo
Оглавление
1. мотивация
2. нелокальные переменные и замыкания
3. Гочки и лучшие практики
3.1. код как данные
3.2. вторжение специальной переменной
3.3. - - -
3.4. смешивание итераций, замыканий и асинхронного программирования
4. инструменты тестирования
4.1. my-lexical-bound-p
4.2. my-print-safe
Часть серии Жизнь с Emacs Lisp

1. мотивация
Допустим, Алиса использовала динамическую область видимости для своего кода на Emacs Lisp, и она обнаружила, что динамическая область имеет серьезные ошибки (например, вы не можете использовать замыкания), поэтому она решает переключиться на использование лексической области (более известной как лексическое связывание в Emacs). Инструкции). Теперь она хочет знать, что есть некоторые ошибки лексического масштаба и как их избежать.

Эта статья длинная, и разделы после - - - можно пропустить.

2. нелокальные переменные и замыкания
Прежде чем углубиться в изучение лексического связывания в Emacs Lisp, давайте рассмотрим пример кода, который требует лексического связывания. Цель состоит в том, чтобы объяснить, что такое нелокальные переменные и замыкания. Те, кто знают, что они, должны перейти к следующему разделу. О том, как заставить файл Emacs Lisp использовать лексическую область, смотрите, как включить Unicode, лексическое связывание, функции CL в файле elisp .

Пример: предположим, что Алиса написала файл Emacs Lisp с лексической областью alice-test.el со следующим содержимым:

  ;;;  - * - лексическая привязка: t;  - * - 
(require 'bob-functions) ; это для bob-repeat

(defun alice-insert-stuff ()
  (interactive)
  ;; вставить "1111111111\n2222222222\n3333333333" в текущем буфере
  (dolist (i (list "1" "2" "3"))
    (bob-repeat 10
               (lambda ()
                 (insert i)))
    (insert "\n")))

Это опирается на библиотеку Боба bob-functions.el с таким содержанием:

(defun bob-repeat (n func)
  "Вызывает FUNC повторно, N раз."
  (dotimes (i n)
    (funcall func)))

(provide 'bob-functions)

Анонимная функция, написанная Алисой, содержит использование i . То, что i - нелокальная переменная (также называемая свободными переменными ) по отношению к анонимной функции, то есть, i нелокальна по отношению к анонимной функции, но она все еще является локальной переменной в alice-insert-stuff .

В следующем коде a1, a2, a3 не являются локальными для внутренней анонимной функции, в то время как b1, b2, b3 являются локальными переменными, установленными в анонимной функции.

(defun my-hello (a1 a2)
  ...
  (dolist (a3 (list 10 10))
    ...
    (lambda (b1 b2)
      (print b1)
      (dolist (b3 (list 10 10 10))
        (print b1 b2 b3)
        (print a1 a2 a3)))
    ...
    ...)
  ...
  ...)

Использование i в alice-insert-stuff и использование одного и того же имени i в bob-repeat не зависят от лексической области действия alice-test.el . Если Алиса удалила первую строку alice-test.el чтобы вместо этого сделать ее динамически ограниченной, функция alice-insert-stuff не будет вести себя так, как задумал Алиса.

Оценка лямбда-формы приводит к функциональному объекту. Функциональный объект, который хранит локальные привязки нелокальных переменных, называется замыканием . Только лексически ограниченный код может генерировать замыкания.

3. Гочки и лучшие практики
3.1. код как данные
3.1.1. выражение в кавычках отключено
  (let ((bark 1010))
  (print (symbol-value 'bark)))
Этот код, если он находится в лексической области, не будет печатать 1010. Может быть, следующий код менее загадочный:

(let (bark
      expression)
  (setq bark 999)
  (setq expression '(1+ bark))
  (eval expression t))

Этот код тоже потерпит неудачу. Причина, по которой значения eval и symbol-value не подходят для лексического контекста, заключается в том, что в кавычках

 'bark

или

 '(1+ bark)

отключены от окружающего их кода. Переменная bark является локальной к выражению (1+ bark) которое заключено в кавычки. Использование нелокальных переменных в выражениях в кавычках не рекомендуется, за исключением глобальных специальных переменных. Это препятствие также распространяется на add-to-list .

Следующее хорошо, потому что load-path является глобальной специальной переменной.

(add-to-list 'load-path "~/.emacs.d/lisp/")

Следующее плохо, потому что animals являются локальной переменной.

(let ((animals nil))
  (add-to-list 'animals "cat")
  (add-to-list 'animals "dog")
  (add-to-list 'animals "dog")
  animals)

Следующее - правильный путь. Это хорошо, потому что animals не указаны. cl-adjoin - это просто функция, которая берет список и возвращает список.

(let ((animals nil))
  (setq animals (cl-adjoin "cat" animals :test #'equal))
  (setq animals (cl-adjoin "dog" animals :test #'equal))
  (setq animals (cl-adjoin "dog" animals :test #'equal))
  animals)

Следующее достигает того же. cl-pushnew - это макрос Lisp, который в этом случае просто расширяется до чего-то подобного выше.



(let ((animals nil))
  (cl-pushnew "cat" animals :test #'equal)
  (cl-pushnew "dog" animals :test #'equal)
  (cl-pushnew "dog" animals :test #'equal)
  animals)

Чтобы добавить строки к animals безоговорочно, смотрите double pointers and Lisp lists (двойные указатели и списки Lisp).

Лучшие практики:

1) вместо определения или использования функции, которая принимает переменную в кавычках в качестве аргумента, как в (my-blah 'x) , определите функцию, которую вы можете использовать с шаблоном (setq x (my-blah-blah x)) .
2) Если (setq x (my-blah-blah x)) слишком длинный для ввода, определите макрос Lisp, используя cl-callf или cl-callf2 .

Давайте вернемся к:

(let (bark
      expression)
  (setq bark 999)
  (setq expression '(1+ bark))
  (eval expression t))
  
Каковы обходные пути для такого рода кода? Одним из обходных путей является использование замыкания вместо выражения в кавычках. Вы можете создавать замыкания, передавать их и вызывать их в любое время. Другой способ - сделать данную переменную глобальной специальной переменной, которая в некоторых случаях может быть неприменима. Иногда синтаксис обратной цитаты может быть обходным путем, например:

 ;;  хорошо. 
(defun my-nah-1 (str)
  (rx-to-string `(+ ,(substring str 1))))
(my-nah-1 "@abc")

 ;;  Плохо. 
(defun my-nah-2 (str)
  (rx-to-string '(+ (eval (substring str 1)))))
(my-nah-2 "@abc")

Кто-то может сказать: "Разве кавычка не похожа на цитату? почему обратная цитата в my-nah-1 OK, а цитата в my-nah-2 не OK?" Использование str в синтаксисе обратной цитаты в my-nah-1 находится вне какой-либо цитируемой части. Помните, что запятая заключает в кавычки выражение в форме обратной кавычки .

Лучшие практики:

1) по возможности избегайте eval
2) избегайте использования выражений в кавычках с намерением ссылаться на внешние локальные переменные
3) передавать замыкания вместо (цитируемых) выражений
3.1.2. цитируется лисповское выражение в лексической области?
То, что вы записали выражение в кавычках в файл с лексической областью, не означает, что это выражение будет выполняться как код с лексической областью.

  ;;;  - * - лексическая привязка: t;  - * - 

(require 'bob-functions)

(defun my-do-something-after-3-seconds ()
  (bob-delayed-eval
   3
   '(progn
      (blah)
      (blah)
      ...)))
      
Progn-форма заключается в кавычки и затем передается в служебную функцию, предоставляемую пакетом bob-functions . Будет ли форма progn оцениваться в лексической области, зависит от того, как bob-delayed-eval обрабатывает ее. Подробнее о том, как это зависит, смотрите how Emacs determines lexical binding on a variable (как Emacs определяет лексическое связывание с переменной).

Когда Emacs оценивает файл, содержащий приведенный выше код, Emacs не дает себе обещания, что он будет оценивать форму progn в лексической области. Это потому, что Emacs считает, что форма progn - это даже не код. Это данные, а не код. Emacs считает, что это похоже на следующий код, в котором даже люди согласны с Emacs, что (1 2 3 4) - это просто данные:

(dolist (i '(1 2 3 4))
  (print i))
  
Что может сделать Боб? Вместо этого он может предоставить bob-delayed-call который принимает функцию в качестве аргумента. Тогда пользователь bob-delayed-call может использовать его следующим образом, не опасаясь потерять лексическую область:

(bob-delayed-call ;боб-задержка-вызова
 3
 (lambda ()
   (blah)
   (blah)
   ...))

Боб может даже предоставить макрос Lisp bob-delayed который является простой оболочкой для bob-delayed-call .

(bob-delayed 3
  (blah)
  (blah)
  ...)
  
3.2. вторжение специальной переменной
invasion of special variables in Emacs Lisp вторжение специальных переменных в Emacs Lisp

3.3. - - -
3.4. смешивание итераций, замыканий и асинхронного программирования
Этот раздел, вероятно, полезен только для программистов JavaScript и тех, кто хочет писать код с большим количеством асинхронных вызовов. Другие должны пропустить этот раздел.

Могут возникнуть проблемы при соблюдении следующих условий:

1) вы производите анонимные функции в цикле
2) функции вызываются после завершения цикла
3) функции используют нелокальные переменные, которые являются переменными цикла, т. е. функции закрывают переменные цикла.
Этот код производит две кнопки с метками яйцо и курица.

cl-loop for word in (list "egg" "chicken") ;egg - яйцо, chicken - курица
         do
         (insert-button word
                        'action
                        (lambda (arg)
                          (message "la %s" word)))
         (insert " "))

Нажатие на кнопку «яйцо» приводит к появлению сообщения «курица», а не «яйцо». Это потому, что cl-loop реализован таким образом, что цикл устанавливает локальную привязку word только один раз. Это делает только одну привязку, а не несколько. Я имею в виду, что цикл делает что-то вроде следующего:

  ;;  Пример P

(let (word)
  (setq word "egg")
  (insert-button word
                 'action
                 (lambda (arg)
                   (message "la %s" word)))
  (insert " ")

  (setq word "chicken")
  (insert-button word
                 'action
                 (lambda (arg)
                   (message "la %s" word)))
  (insert " "))

Таким образом, устанавливается только одно связывание word . К тому времени, когда кнопка нажата, word в этой привязке относится к «курица». С другой стороны, следующий код устанавливает две привязки word :

  ;;;  Пример Q 

(let ((word "egg"))
  (insert-button word
                 'action
                 (lambda (arg)
                   (message "la %s" word)))
  (insert " "))

(let ((word "chicken"))
  (insert-button word
                 'action
                 (lambda (arg)
                   (message "la %s" word)))
  (insert " "))

С помощью приведенного выше кода кнопка «яйцо» будет отображать «la egg», а кнопка «курица» будет отображать «la chicken». В этом случае к моменту нажатия любой кнопки происходит две привязки word , word name относится к разным строкам в двух привязках. Одно имя, в данном случае word , относящееся к разным вещам в разных привязках одновременно, не является какой-то уникальной странной стороной Emacs Lisp. Если вы написали рекурсивные функции или работали с потоками или замыканиями на других языках, вы уже знакомы с явлениями одного имени, относящимися ко многим вещам одновременно. Непрограммисты также знакомы с этим явлением: имя Боб относится к разным людям в разных привязках. Имя «Президент» относится к разным лицам в разных связях. На момент написания статьи (2013) имя «Президент» относится к парню справа (Барак Обама) на этой картине в американском переплете, в то время как то же имя относится к женщине слева (Пак Кын Хе) на юге. Корейский переплет Позвольте мне связать эту аналогию с примером P и примером Q выше.

Пример P выглядит следующим образом: американец родился, когда Джордж Буш был президентом Соединенных Штатов, а затем еще один американец родился, когда Барак Обама стал президентом. Теперь, если мы спросим их «кто сейчас президент?», Они оба ответят Бараку Обаме. Двое американских детей делят одну привязку президента.

Пример Q выглядит следующим образом: кореец родился, а Пак - президент Южной Кореи, а затем родился американец, а Обама - президент США. Теперь, если мы спросим их «кто сейчас президент?», Один ответит «Парк», а другой «Обама». Двое детей используют разные привязки президента.

С помощью следующего кода две кнопки отображают различные сообщения, как и предполагалось. Отличие от первого примера cl-loop состоит в том, что теперь нелокальная переменная, которая в этот раз является msg , не является переменной цикла и что цикл устанавливает две привязки msg просто потому, что цикл дважды входит в форму let.

(cl-loop for word in (list "egg" "chicken")
         do
         (let ((msg (message "la %s" word)))
           (insert-button word
                          'action
                          (lambda (arg)
                            (message msg)))
           (insert " ")))

Следующий код также работает как задумано, что является просто вариантом вышеупомянутого:

(cl-loop for word in (list "egg" "chicken")
         do
         (let ((word word))
           (insert-button word
                          'action
                          (lambda (arg)
                            (message "la %s" word)))
           (insert " ")))
Этот код фактически создает три привязки word : одну внешнюю привязку и две внутренние привязки. Две кнопки используют две внутренние привязки.

Это был самый общий обходной путь. Есть и другие обходные пути, такие как:

1) используйте вместо этого mapc который принимает функцию
2)используйте другой макрос цикла, который создает несколько привязок переменной цикла (и так задокументировано)
3)прикрепить информацию (например, word или msg ) к кнопкам и позволить функциям кнопок извлекать информацию

4. инструменты тестирования
Вот два макроса Lisp, которые я использовал для тестирования, когда готовил эту статью.

4.1. my-lexical-bound-p

(defmacro my-lexical-bound-p (var)
  "Returns t if VAR is going to work as a lexically bound variable. Nil otherwise."
  `(let ((,var nil)
         (f (let ((,var t)) (lambda () ,var))))
     (funcall f)))

Вы можете использовать макрос следующим образом:

(my-lexical-bound-p sodjosijf)
(my-lexical-bound-p case-fold-search)

Запустите это в лексической области, а затем в динамической области. Вы также можете использовать его для проверки взаимодействия между eval-after-load и лексической областью действия:

(provide 'my-10)
(eval-after-load 'my-10
  '(print
    (list
     'my-10
     (my-lexical-bound-p osijosf))))
(eval-after-load 'my-20
  '(print
    (list
     'my-20
     (my-lexical-bound-p osijosf))))
(provide 'my-20)

4.2. my-print-safe

(defmacro my-print-safe (object)
  "Prints OBJECT. If error, prints error."
  `(progn
     (condition-case err
         (progn
           (print ,object))
       (error
        (terpri)
        (princ (format "Eval of %S resulted in error %S"
                       ',object err))
        (terpri)))))

Используя макрос, я запустил следующий код в лексической и динамической областях, чтобы проверить свои предположения.

(let ((bark 0)
      (f (let ((bark 100))
           (lambda ()
             (my-print-safe bark) ; 100 в лексической области, в противном случае 0.
             (my-print-safe
              `(:ha ,bark
                    ,(1+ bark)
                    ,(list bark `(,bark ,bark))))
             (my-print-safe (symbol-value 'bark))
             (my-print-safe (eval '(1+ bark) lexical-binding))
             (my-print-safe `,bark)))))
  (funcall f)
  t)
