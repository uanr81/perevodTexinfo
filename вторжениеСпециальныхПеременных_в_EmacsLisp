Вторжение Специальных Переменных в Emacs Lisp
Оглавление
1. Вторжение специальных переменных
2. Соглашение об именовании для специальных переменных
3. Соглашение о присвоении зеленых названий для (лексических) локальных переменных
4. как насчет случайных глобальных переменных?
5. - - -
6. байтовая компиляция устраняет коллизию?
7. подробные примеры столкновений
7.1. Передача асинхронной функции обратного вызова (которая включает нелокальную переменную)
7.2. передача асинхронного кода обратного вызова
7.3. передача функции синхронного обратного вызова
7.4. передача синхронного кода обратного вызова
7,5. середина подведения итогов
7,6. возвращение анонимной функции (которая является закрытием)
7.7. пример локальной функции
8. Общая записка на Лиспе

Этот пост является частью Living with Emacs Lisp . Этот пост очень длинный, и вам, вероятно, не нужно читать разделы после - - -части.

1. Вторжение специальных переменных
Вторжение специальных переменных может произойти, если выполняются следующие два условия

1)файл lisp emacs использует defvar, defcustom или defconst для объявления глобальной специальной переменной
2)другой файл lisp в emacs использует локальную переменную с лексической областью с тем же именем, что и глобальная специальная переменная из другого файла lisp в emacs.

В результате поведение кода последнего файла может стать ненадежным, хотя и не всегда. Это как если бы последний файл был захвачен глобальной специальной переменной. Другой путь - вторжение локальных переменных .

Это происходит из-за свойства defvar, которое Эранн Гат назвал "распространением defvar". Код (defvar abc)объявляет abc специальное имя , которое делает abc его динамически связанным, а не лексически связанным, во всех файлах emacs lisp, включая файлы, имена которых имеют локальную переменную abc, даже файлы, загруженные до выполнения (defvar abc), даже файлы которые написаны другими командами, а иногда даже теми, которые байт-скомпилированы.

Например, однажды Алиса устанавливает emacs-html-server.el для запуска html-сервер в Emacs. (пакеты, упомянутые в примерах здесь, все составлены, если не указано иное.) Давайте предположим, что emacs-html-server.el определяет команду, ehs-start-server которая использует локальную переменную с именем python-path. Затем другой день, Алиса устанавливает python-mode.el. Предположим, python-mode.el содержит эту строку:

(defvar python-path "python" "Path to Python executible.");"Путь к исполняемому файлу Python."

После установки она обнаруживает, что ehs-start-server команда перестает работать, как только она открывает буфер режима Python.

Другой пример. Однажды Алиса устанавливает print-to-pdf.el для печати буферов в PDF-файлы. Давайте предположим, что print-to-pdf.el определяет команду, ptp-print-and-open которая принимает необязательный параметр print-newline. Затем в другой день выходит новая версия Emacs. Давайте предположим, что в этой версии вводится print-newline как глобальная специальная переменная, которая определяет, как print должна вести себя функция . После установки этой версии Emacs она обнаруживает, что команда ptp-print-and-open работает не так, как раньше.

Мы рассмотрим более подробные примеры позже, чтобы увидеть точные условия, в которых вторжение вызывает серьезные столкновения. Есть меры, которые вы можете предпринять, чтобы уменьшить столкновение. Во-первых, позвольте мне рассказать вам историю о Бобе. Боб готовил что-то на ужин. Ужин был рисовыми гамбургерами с курицей, помидорами, салатом и т.п. Его кошка наблюдала за его приготовлением и нашла что-то смешное в том, как готовил Боб. Боб использовал две разделочные доски. Он использовал желтую доску для нарезки сырой курицы и зеленую доску для нарезки помидоров и салата. Его кошка спросила "почему две разделочные доски?" Он ответил: "Мой отец сказал мне, что использование двух досок - это хорошая привычка, потому что это снижает вероятность перекрестного загрязнения". Желтая доска для (глобальных) специальных переменных. Зеленая доска для (лексически ограниченных) локальных переменных.

2. Соглашение об именовании для специальных переменных
Убедитесь, что в специальных переменных есть имена с дефисом. Например, если вы используете defvar для создания глобальной переменной в вашем файле инициализации emacs, вы должны назвать переменную с общим префиксом (с дефисом), например, my-или jh- если jh - ваши инициалы.

;; в файле инициализации emacs
 
;; in emacs init file

(defvar my-abc nil "blah.")

(defvar my-xyz nil "blah.")

(defconst my-in-ms-windows (eq system-type 'windows-nt)
  "Non-nil if this is on MS Windows.")
  
Если вы являетесь автором пакета, у вас будет общий префикс для имен всех специальных переменных и функций в вашем пакете. Даже специальные переменные для внутреннего использования должны быть названы с таким общим префиксом. Например, python.el выбирает python- в качестве общего префикса.

;; в python.el

(defvar python-mode-map ...)

(defcustom python-indent-offset ...)

(defvar python--timer ...) ; для внутреннего использования

3. Соглашение о присвоении зеленых названий для (лексических) локальных переменных
Вы можете выбрать одно из следующих трех возможных правил, одно из которых вы можете выбрать для подписки:

Правило 1: В любом lisp-файле emacs с параметром lexical-binding установленным в t, все переменные должны объявляться с именами без дефисов , кроме случаев определения глобальных специальных переменных. Например, с такими именами как pythonpath, python_path и path все OK, а с именами вроде python-pathнет нет.

Правило 2: В любом файле emacs lisp с lexical-binding установленным в t, все переменные, упомянутые в теле анонимной функции (или теле локальной функции, если вы используете cl-flet), за исключением глобальных специальных переменных, определенных в этом файле или в других необходимых файлах, должны иметь имена без дефисов. Другими словами, в отличие от правила 1, вы можете объявить (лексическую) локальную переменную с именами с дефисами, если вы не используете эту переменную в теле анонимной функции.

Правило 3: В любом файле lisp emacs с lexical-binding установленным в t, все нелокальные переменные, упомянутые в теле анонимной функции или в теле локальной функции, за исключением глобальных специальных переменных, должны иметь имена без дефисов.

Правило 1 является наименее разрешающим из имен с дефисами, а Правило 3 - наиболее разрешающим. Правило 1 требует наименьшего количества размышлений, а правило 3 - больше.

Какое бы правило вы ни выбрали, не забывайте, что параметры функции также являются локальными переменными, и поэтому вы должны следовать этому правилу, когда выбираете имена для параметров функции.

Есть несколько встроенных специальных переменных с именами без дефисов , вам следует избегать этих имен.

( Обновление : Кроме того, хотя любого из этих правил достаточно для защиты от вторжения специальных переменных, ни одного из них недостаточно для предотвращения вторжения локальных переменных. См. Вторжение локальных переменных в Emacs Lisp . Один из подходов этой статьи может быть по имени Правило 0.

Правило 0: В любом файле lisp emacs все локальные переменные должны быть объявлены с именами без дефисов.)

Если вы работаете с правилом 2 или 3, вы должны знать, что очень легко в конечном итоге ввести анонимные функции, иногда даже не замечая этого. Например, вы, скорее всего, будете использовать анонимные функции, если вы часто используете mapcar. Возможно, вы используете какой-то причудливый цикличный макрос из некоторой библиотеки, которая реализована с помощью замыканий, то есть макрос может писать анонимные функции для вас, не обращая на это внимания. Макросы, такие как макрос with-process-shell-command от Nic Ferrier, также делают замыкание из кода, который вы передаете, для например.

4. как насчет случайных глобальных переменных?
Многие статьи об использовании Emacs Lisp setq (вместо defvar), чтобы ввести глобальные переменные с простыми именами , как list, list1, x, y в коротких примерах кода. Там нет дефисов. Например, следующий код взят из официальной статьи о знаках и использует setq для создания глобальной переменной m.

(setq m (mark-marker))
(set-marker m 100)
(mark-marker)

Глобальная переменная m является случайной глобальной переменной: она используется только в учебных целях, для тестирования, она не используется как часть кода для пакетов или вашего файла инициализации.

Глобальные переменные, созданные с помощью setq, не являются специальными переменными и, следовательно, не вызывают вторжение специальных переменных (верно для Emacs 24). Это означает, что соглашение об именовании желтого цвета не применяется к глобальным переменным из setq. Но такое поведение setq никогда не упоминается в руководствах, насколько мне известно. Поэтому возможно, что будущие emacs могут изменить поведение setq так, чтобы он создавал специальные переменные. В этом случае вы должны начать именовать все глобальные переменные (независимо от того, были ли они созданы setq или defvar) с дефисами в именах.

5. - - -
6. байтовая компиляция устраняет коллизию?
Байтовая компиляция помогает уменьшить вероятность вторжения специальных переменных, поскольку она имеет тенденцию удалять упоминания имен локальных переменных, но все же следует полагаться на соглашения об именах переменных.

Мы не можем полагаться только на байтовую компиляцию, потому что, например, даже если автор emacs-html-server.el распространяет только байтовые скомпилированные файлы, он все равно должен запускаться emacs-html-server.el без байтовой компиляции во время интерактивной разработки пакета. Кроме того, когда Алиса устанавливает python-mode.el из архива пакета, а затем открывает буфер режима Python, а затем устанавливает emacs-html-server.el из архива пакета и выполняет его байтную компиляцию, она может получить скомпилированный байтовый код, для ehs-start-server которого все еще упоминается имя python-path.

Кроме того, что если использование defadvice или отладка чего-либо каким-либо образом компилирует некоторые скомпилированные функции? Это случается? Я не знаю.

Другое дело, что люди редко компилируют свои файлы инициализации emacs.

Еще одна вещь, я не уверен, что байтовая компиляция, исключающая упоминания имен локальных переменных, является явно документированным поведением.

7. подробные примеры столкновений
Все имена файлов emacs lisp или все имена пакетов emacs lisp в этих примерах являются гипотетическими, если не указано иное.

7.1. Передача асинхронной функции обратного вызова (которая включает нелокальную переменную)
Предположим, Алиса является пользователем example.el и some.el. Предположим, в example.el есть функция, которая делает запросы xhr и получает ответы, используя xhr-get функцию, которая определена в xhr.el.

;;; example.el --- пример материала - * - лексическое связывание: t - * -
 
(require 'xhr)

...

(defun example-something ()
  (dolist (some-query (list "x" "y" "z"))
    (xhr-get
     (format "http://www.example.com/%s" some-query)
     (lambda (response status)
       (message "%s => %s" some-query response)))))

...

Обратите внимание, что some-query это имя переменной, которая является нелокальной переменной для функции анонимного обратного вызова. Это нарушает правило 3.

А вот содержимое some.el:

;;; Some.el --- некоторые вещи

...

(defvar some-query "query" "some.el query command")
(defvar some-version 1.2 "some.el version")
...
Обратите внимание, что этот файл объявляет some-query специальной переменной.

Если example.el и some.el загружены в одном сеансе Emacs, функция example-something не будет работать должным образом, потому что имя some-query разрешается динамическим связыванием даже внутри example.el, и поэтому не будет ссылаться на предполагаемые значения, такие как "x", "y" или "z" в то время вызывается функция анонимного обратного вызова, которая выполняется после завершения выполнения формы dolist. 

7.2. передача асинхронного кода обратного вызова
Этот пример является небольшой модификацией предыдущего примера. Предположим, что xhr.el предоставляет макрос Lisp, xhr-with-get который похож на xhr-get, за исключением того, что он принимает код обратного вызова вместо функции обратного вызова и что макрос реализован с использованием xhr-get очевидного способа. Предположим, example.el определяет макрос example-something-2 и использует этот макрос:

;;; example.el --- пример материала - * - лексическое связывание: t - * -

(require 'xhr)

...

(defun example-something-2 ()
  (dolist (some-query (list "x" "y" "z"))
    (xhr-with-get (format "http://www.example.com/%s" some-query)
        (response status)
      (message "%s => %s" some-query response))))

...

Это все еще как бы нарушает Правило 3.

Если example.el и some.el загружены в одном сеансе Emacs, функция example-something-2 не будет работать так, как задумано.

xhr-with-get реализована так:

(defmacro xhr-with-get (url vars &rest body)
  "Примечание: используйте этот макрос только в файлах Emacs Lisp с лексической привязкой" 
(declare (indent 2))
  `(xhr-get ,url (lambda ,vars ,@body)))

7.3. передача функции синхронного обратного вызова
Предположим, что Алиса является пользователем hello.el, который определяет hello-insert-stuff команду, которая, в свою очередь, опирается на fp-repeat функцию, определенную в fp.el (которую мы предполагаем, что это библиотека, предоставляющая множество функций для функционального программирования, написанного Бобом), и предположим, что fp-repeat многократно вызывает функцию.

;;; hello.el --- hello stuff - * - лексическое связывание: t; - * -
 
(require 'fp)

(defun hello-insert-stuff ()
  (interactive)
  ;; вставляет "1111111111\n2222222222\n3333333333" в текущий буфер
(dolist (i (list "1" "2" "3"))
    (fp-repeat 10
               (lambda ()
                 (insert i)))
    (insert "\n")))

...
Предположим fp-repeat, реализована так:

;;; fp.el --- fp stuff - * - лексическое связывание: t; - * -

...

(defun fp-repeat (n func)
  "Вызывает FUNC повторно, N раз." 
(dotimes (i n)
    (funcall func)))
...
Теперь предположим, что Алиса имеет привычку использовать defvar с произвольными именами для своих случайных глобальных переменных, тем самым нарушая соглашение об именовании для желтых специальных переменных. Сегодня Алиса заинтересовалась арифметическими операторами и запустила следующий код в пустом буфере, чтобы увидеть, как они работают с более чем двумя аргументами.

(defvar i 100)
(defvar j 200)
(defvar k 300)

(print (+ i j k))
(print (* i j k))
(print (- i j k))
(print (/ i j k))

Запуск этого кода имеет неприятный побочный эффект - нарушает предполагаемое поведение hello-insert-stuff. Это потому, что он объявляет специальную переменную i, и когда Алиса запустит hello-insert-stuff позже, она вставит "0123456789\n0123456789\n0123456789" вместо предполагаемого "1111111111\n2222222222\n3333333333», потому что динамическая привязка, i установленная из fp-repeat вызовов, будет затенять другие привязки.

7.4. передача синхронного кода обратного вызова
Этот пример является небольшой модификацией предыдущего примера. Предположим, что hello.el определяет hello-insert-stuff-2, hello-insert-stuff кроме этого использует fp-repeat-do. Предположим fp-repeat-do, это макрос Lisp, определенный в fp.el и просто версия макроса fp-repeat.

(defun hello-insert-stuff-2 ()
  (interactive)
  ;; вставляет "1111111111 \ n2222222222 \ n3333333333" в текущий буфер
  (dolist (i (list "1" "2" "3"))
    (fp-repeat-do 10
      (insert i))
    (insert "\n")))

Мы также предполагаем, что fp-repeat-do это реализовано с использованием fp-repeat:



(defmacro fp-repeat-do (n &rest body)
  "Note: use this macro only in lexical bound Emacs Lisp files"
  (declare (indent 1))
  `(fp-repeat ,n
              (lambda () ,@body)))

Алиса, выполняющая свой код для проверки арифметических операций, также нарушает предполагаемое поведение hello-insert-stuff-2.

7,5. середина подведения итогов
Кто-то, отклоняющийся от соглашений об именах, упомянутых в этом посте, вызывает коллизию, которая затем нарушает предполагаемое поведение чужого кода, который включает передачу обратных вызовов.

7,6. возвращение анонимной функции (которая является закрытием)
Предположим, fp.el определяет fp-counter, который возвращает своего рода генератор чисел, которые начинаются с определенного значения с определенным шагом. Например, (fp-counter 100 2) возвращает функцию, которая возвращает 100, 102, 104, ... при повторных вызовах.

(defun fp-counter (count-start count-step)
  (let ((current-number count-start))
    (lambda ()
      (prog1
          current-number
        (setq current-number (+ current-number count-step))))))

Обратите внимание, что автор fp.el дважды нарушил правило 3 в этом коде: current-number и count-step.

Теперь предположим, что Алиса устанавливает, что current.el, как мы полагаем, представляет собой пакет emacs lisp для сообщения о количестве электрического тока, проходящего через Emacs. Что это значит. Я не знаю. Во всяком случае, предположим, что в current.el включили эту строку:

(defvar current-number nil
  "Количество электрического тока в чайных ложках.
    Этот номер обновляется каждые `current-update-interval'секунд")

Когда Алиса включает сообщение об электрическом токе, все, на что она опирается fp-counter, сломается.

7.7. пример локальной функции
Я не могу придумать хороший пример, сочетающий нарушение соглашений об именах и использование локальных функций, что приводит к проблемам.

8. Общая записка на Лиспе
Программисты Common Lisp используют другой способ устранения вторжений: соглашение о наушниках. Они ставят звездочки вокруг специальных имен переменных, и эти звездочки называются наушниками. Есть парень 4, который годами не пользовался соглашением о наушниках. Я не знаю о Common Lisp, но с Emacs Lisp, если вы не будете придерживаться соглашений об именах, ваш код будет вторгаться в код других и наоборот.

Еще одно отличие. setq-привязывание неопределенного имени переменной на верхнем уровне может выполнять одно из следующих трех действий в зависимости от реализаций Common Lisp:

1) ошибку
2) создаст лексическую глобальную переменную, то есть объявляет глобальную переменную (или, на языке Lisp, устанавливает глобальное значение переменной), не делая ее особенной (или на языке Common Lisp, не объявляя ее особой).
3) создает глобальную специальную переменную.
