двойные указатели и LISP списки
Posted on July 14, 2013	by Jisang Yoo
Оглавление

    1. написать функцию, которая возвращает результат вместо
    2. написать макрос
    3. передавая символ
    4. - - -
    5. бокс и распаковка
    6. которые временное решение использовать
    7. теперь четвёртую проблема: несколько возвращаемых значений
    8. Common Lisp примечание

Эта статья является частью серии Жизнь с Emacs Lisp. Эта статья немного долго, и новичкам, вероятно, не нужно читать разделы после - - - части.

Алиса C программист и новичок Lisp. Однажды, Алиса пишет код Lisp и попадаются проблемы. Проблема в том, что она будет использовать двойные указатели так если бы она пишет в C. Lisp, кажется, не имеет двойные указатели. Она застревает. Хорошее решение, когда застрял, временно отказаться от этой проблемы, и придумать более простую задачу и попытаться решить, её первой. Алиса, хорошо решает проблемы, приходит к простейшей задачи, а именно:

“Я не могу написать функцию Lisp, которая принимает список и добавляет элемент в голову списка. Что теперь?”

В самом деле, что теперь? Есть много способов обойти эту проблему, но, прежде чем идти, позвольте мне представить вторую проблему, немного сложнее, чем первая проблема:

“Я не могу написать функцию Lisp, которая принимает список и добавляет элемент в голову списка, если элемент не находится в списке. Что теперь?”

и третья проблема:

“Я не могу написать функцию Lisp, которая удаляет элемент из головы списка. Что теперь?”

Все примеры в этой статье, для Emacs Lisp. Давайте посмотрим, обходные.
1. написать функцию, которая возвращает результат вместо

Вы не можете написать функцию, которая делает работу, но вы можете написать функцию, которая возвращает результат, который вы хотите, которые вы можете установить обратно в переменную. За три проблемы, которые я упомянул, вы не должны писать такие функции, потому что Emacs Lisp уже предоставляет их: cons и cl-adjoin и cdr.

(setq numbers (list 10 20 30))

(setq numbers (cons 0 numbers))
(print numbers)
;; ⇒ (0 10 20 30)

(setq numbers (cdr numbers))
(print numbers)
;; ⇒ (10 20 30)

(require 'cl-lib)
(setq numbers (cl-adjoin 30 numbers))
(setq numbers (cl-adjoin 40 numbers))
(print numbers)
;; ⇒ (40 10 20 30)

2. написать макрос

Вы не можете написать функцию, которая делает работу, но вы можете написать макрос, который просто расширяется к предыдущему обходного. Такой макрос обычно называется Modify макросъемки. Для этих двух проблем, вы не должны писать такие макросы, потому что Emacs Lisp уже предоставляют их: push и cl-push-new и pop.

(setq numbers (list 10 20 30))

(push 0 numbers)
(print numbers)
;; ⇒ (0 10 20 30)

(pop numbers)
(print numbers)
;; ⇒ (10 20 30)

(require 'cl-lib)
(cl-pushnew 30 numbers)
(cl-pushnew 40 numbers)
(print numbers)
;; ⇒ (40 10 20 30)

Вы можете проверить cl-callf и cl-callf2, которые помогут вам написать или изменить макрос легко.
3. передавая символ

Вы можете написать функцию, которая принимает символ, из которого функция может получить доступ к списку. Для второй задачи, Emacs Lisp уже предоставляют такую ​​функцию:

(setq numbers (list 10 20 30))

(add-to-list 'numbers 30)
(add-to-list 'numbers 40)
(print numbers)
;; ⇒ (40 10 20 30)

Такие функции не отрабатывают хорошо с лексической областью видимости. Таким образом, вы не должны использовать такие функции с локальными переменными
4. - - -
5. бокс и распаковка

Вы можете написать функцию, которая принимает упакованный объект, из которого функция может получить доступ к списку. Тип упакованного объекта, который вы выбрали для этой цели может быть все, что может содержать список. Это может быть vector, cons, или даже список. Это решение приведет к ухудшению читаемости кода.
6. which workaround to use

Мы видели много обходных путей. Я рекомендую первый обходной путь. Второй обходной путь (макросы) требует от вас написания макросов, но зачем писать макрос, когда вы можете полагаться только на первый обходной путь? Два других обходные пути, как используются двойные указатели в C. Я не думаю, что использование двойных указателей в Lisp является рекомендуемой практикой.

7. теперь четвёртую проблема: несколько возвращаемых значений

“Что я могу сделать, когда я хочу чтобы функцию возвращала несколько результатов?”

Вы можете просто вернуть несколько результатов как один список, в этом случае вы можете захотеть использовать cl-destructuring-bind со стороны вызывающего абонента.

Или вы можете сделать функцию принимает функцию обратного вызова в качестве аргумента, и передать свои несколько результатов в качестве аргументов функции обратного вызова. В этом случае, вы должны включить лексическую область видимости.
8. Common Lisp примечание

Common Lisp, в отличие от Emacs Lisp, поддерживает несколько возвращаемых значений. Он также имеет принципиально иной способ обработки исключений, отличные от Emacs Lisp и C и других языков.

Я не»думать Common Lisp предоставляет callf, callf2, add-to-list.
